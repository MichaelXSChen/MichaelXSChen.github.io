---
layout: post
title:  On the Usage of Atomic Clocks in Spanner
date:   2022-04-1
description: Spanner use Atomic Clocks for read-only transactions. 
tags: consistency, distributed-database
categories: thoughts
---

**Draft, WIP, need proofread**

The Spanner {% cite spanner --file ref %} system is well studied since it is published 
in OSDI '12, and many geo-distributed databases (e.g., CockroachDB) following 
Spanner have been built. Everyone knows that Spanner uses
TrueTime/Atomic clocks to achieve 
strict serializability (linearizability), but a key question 
that I want to answer is *what is the role of the TrueTime API in
Spanner's protocol?* How does it contribute to Spanner's guarantee?
How should we design a system without such atomic clocks?


## Spanner in a Nutshell

Spanner is the geo-distributed database built by Google, and its technical 
paper was first published in OSDI '12. 

Spanner has a data model that is stronger than key-value stores but weaker 
than fully relational databases.  
Spanners adopts a layered design, with concurrency control (2PL) on top of 
replication (Paxos). This is a standard design easy to maintain, but it may 
cause extra RTTs. Spanner has three types of transactions, namely read-write (RW) transactions, 
consistent read-only 
transactions (RO), and stale snapshot (the namings may be 
a little bit different from its original paper). 

The key weapon of Spanner is its TrueTime API based on atomic clocks and GPS. 
The TrueTime API has a guaranteed (at least practically) offset among 
clocks. Compared to traditional non-synchronized clocks, a node 
in Spanner can predicate that a remote node's clock has passed $$T$$ 
without communication, which brings Spanner unique strength on efficiently 
ensuring consistency. 

## Spanner's Consistency/Isolation

For read-write (RW) transactions, Spanner uses (strict) 2PL for concurrency control and 
uses leader-based Paxos for replication. A RW transaction is triggered by its client: the 
client first acquire all read locks, read all values, and buffer all writes; 
then a client acquire all write locks and commit via 2PC. This is a standard 2PL and it actually 
already ensures Strict Serializability (even with replication, as all read/write requests
go through the leader) without TrueTime. 

For read-only (RO) transactions, Spanner use TrueTime to ensure their consistency. 
For consistency, there are two main requirements for a RO transaction $$R$$ at timestamp $$ts$$. 
First, Spanner needs to ensure that $$R$$ sees *all* transaction writes with timestamps smaller than
$$ts$$. This completeness enures *atomicity* because updates from the same transaction share the 
same timestamp. The completeness also ensures 

 is ensured by Spanner's safe timestamp 

Second, 


{% bibliography --file ref --cited --template post-ref %}
