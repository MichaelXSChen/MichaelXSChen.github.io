<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="https://michaelxschen.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://michaelxschen.github.io/" rel="alternate" type="text/html" hreflang="en" /><updated>2022-09-12T07:37:12+00:00</updated><id>https://michaelxschen.github.io/feed.xml</id><title type="html">Xusheng Chen’s Homepage</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design.
</subtitle><entry><title type="html">About ballots in Paxos</title><link href="https://michaelxschen.github.io/blog/2022/paxos/" rel="alternate" type="text/html" title="About ballots in Paxos" /><published>2022-06-15T00:00:00+00:00</published><updated>2022-06-15T00:00:00+00:00</updated><id>https://michaelxschen.github.io/blog/2022/paxos</id><content type="html" xml:base="https://michaelxschen.github.io/blog/2022/paxos/"><![CDATA[<p>Recently I am reading papers about asynchronous consensus protocols, and I was 
trying to contrast these protocols with Paxos <a class="citation" href="#paxos">(Lamport, 2001)</a> and PBFT <a class="citation" href="#pbft">(Castro et al., 1999)</a>. 
When re-reading the Paxos
paper, some of the design points take me some time to reason about. 
These thoughts may seem naive for Paxos experts, but I will just jot them down.</p>

<p>In Paxos, a value is confirmed only if it is accepted <em>with the same ballot</em> by a majority
of acceptors. Why is having a majority of acceptors accept the same value not enough?</p>

<p>(At first, I thought the <em>accept</em> action in Paxos corresponds to <em>decide</em> in Ben-Or’s algorithm <a class="citation" href="#benor">(Ben-Or, 1983)</a>, and thus
I was wondering why Ben-Or’s algorithm can let nodes decide a value <em>in different rounds</em>, 
but Paxos requires a majority of nodes to accept <em>with the same ballot</em>. However, this 
comparison is wrong. Ben-Or’s <em>decide</em> is more like the behavior of learners in 
Paxos, and Ben-Or’s algorithm can be regarded as skipping the first phase of Paxos if 
we have to parallelize them.)</p>

<p>To answer this question, we can simply construct a counterexample which shows that, after a majority
of acceptors have accepted a same value \(v\) with different ballots, the system may decide 
a different value \(v'\). I will use \((n, v)\) to denote a proposal of value \(v\) with ballot \(n\).</p>

<p>Let’s use the simplest setting with 3 acceptors \(A_1, A_2, A_3\), where \(A_1\) has accepted \((n_1, v)\)
and \(A_2\) has accepted \((n_2, v)\). Without losing generality, let \(n_1 &lt; n_2\). Now we want one of 
them to switch to accept another value \((n', v')\) (after which another proposer can let the system accept
\(v'\) by forming a majority with \(A_3\)). For simplicity, we assume there are no other concurrent 
proposals.</p>

<p>If the prepare message of $n’$ arrives after \(A_1\) and \(A_2\) accept \(v\), its proposer will learn
and propose \(v\), so at least one of  \(A_1\) and \(A_2\) must prepare \(n'\) before accepting \(v\). On the other hand,
\(n'\) cannot be smaller than both \(n_1\) and \(n_2\), otherwise they will ignore the accept message for 
\(v'\), so we have \(n_1 &lt; n' &lt; n_2\).</p>

<p>We visualize the construction below. A new proposer can use \(A_1, A_3\) to form a majority, and let the system 
accept \(v_2\) at the end, even if two acceptors have accepted \(v_1\) with different ballots at some time.</p>

<p><img src="/assets/figures/paxos-ballot.png" alt="Paxos-Ballot" /></p>

<p>Overall, in Paxos, although an acceptor will try to let subsequent proposers follow
its accepted value, the proposer can find a majority/quorum without including this acceptor.
Even if a majority of acceptors accept the same value \(v\), if they are not of the same ballot, another 
proposer can still succeed in letting a majority of acceptors prepare a ballot that lies 
in the gap among the accepted ballots for \(v\) before they all accept \(v\).</p>

<p>This makes me think about another possible design. <em>What if we can have a method 
that makes there no gap between the ballots for accepting the same value?</em> I did
not conduct a formal proof, but it seems to be enough for correctness. However, how can 
we ensure there are no new ballots can be inserted? Using consecutive integers? Using<br />
timestamps and safe timestamp mechanism?</p>

<p>Another thought is about the proposed value. In Ben-Or’s algorithm, a node tries to follow the value from other nodes in its Phase-1
in order to facilitate convergence. In contrast, in Phase-1 of Paxos, the
proposer does not follow the value prepared by acceptors; its proposed 
value is affected only by accepted values.</p>

<p>What if we adapt Paxos and let a proposer follow the value observed in Phase-1. I was 
thinking this may make it possible to enable Paxos to confirm a value by accepting it value with different ballots.
However, by simple variants of the previous construction, we can see that it is not correct. However, will this 
adaption cannot make the consecutive-ballot design viable?</p>

<p>Anyway, these are just some random thought, and I did not spend much time to verify them, as 
the vanilla Paxos (Paxos-made-simple without a stable leader) is rarely used in deployments.</p>

<h2 id="references">References:</h2>

<ol class="bibliography"><li><!-- _layouts/bib.html -->
      <div class="row">
        <!-- Entry bib key -->
        <div id="paxos" class="col-sm-12">
        
          <!-- Author -->
          <span class="author">Leslie Lamport
          </span>.
          <!-- Title -->
          <span class="title">Paxos made simple</span>.
          <!-- Journal/Book title and date -->
          <span class="periodical">
            <em>ACM SIGACT News (Distributed Computing Column) 32, 4 (Whole Number 121, December 2001)</em> 2001
          </span>
        
          <!-- Links/Buttons -->
          <div class="links">
          </div>

          
        </div>
      </div>
</li>
<li><!-- _layouts/bib.html -->
      <div class="row">
        <!-- Entry bib key -->
        <div id="pbft" class="col-sm-12">
        
          <!-- Author -->
          <span class="author">Miguel Castro, &nbsp;Barbara Liskov, &nbsp;and  others
          </span>.
          <!-- Title -->
          <span class="title">Practical byzantine fault tolerance</span>.
          <!-- Journal/Book title and date -->
          <span class="periodical">
            <em>In OsDI</em> 1999
          </span>
        
          <!-- Links/Buttons -->
          <div class="links">
          </div>

          
        </div>
      </div>
</li>
<li><!-- _layouts/bib.html -->
      <div class="row">
        <!-- Entry bib key -->
        <div id="benor" class="col-sm-12">
        
          <!-- Author -->
          <span class="author">Michael Ben-Or
          </span>.
          <!-- Title -->
          <span class="title">Another advantage of free choice (extended abstract) completely asynchronous agreement protocols</span>.
          <!-- Journal/Book title and date -->
          <span class="periodical">
            <em>In Proceedings of the second annual ACM symposium on Principles of distributed computing</em> 1983
          </span>
        
          <!-- Links/Buttons -->
          <div class="links">
          </div>

          
        </div>
      </div>
</li></ol>]]></content><author><name></name></author><category term="thoughts" /><category term="consistency" /><summary type="html"><![CDATA[Why does Paxos need majority acceptance of a value with the same ballot?]]></summary></entry><entry><title type="html">On the Usage of Atomic Clocks in Spanner</title><link href="https://michaelxschen.github.io/blog/2022/spanner/" rel="alternate" type="text/html" title="On the Usage of Atomic Clocks in Spanner" /><published>2022-04-01T00:00:00+00:00</published><updated>2022-04-01T00:00:00+00:00</updated><id>https://michaelxschen.github.io/blog/2022/spanner</id><content type="html" xml:base="https://michaelxschen.github.io/blog/2022/spanner/"><![CDATA[<p>The Spanner <a class="citation" href="#spanner">(Corbett et al., 2013)</a> system has been well studied since it was published 
in OSDI ‘12, and many geo-distributed databases (e.g., CockroachDB) following 
Spanner have been built. Everyone knows that Spanner uses
TrueTime/Atomic clocks to achieve 
strict serializability (linearizability), but a key question 
that I want to answer here is <em>what role TrueTime plays in
Spanner’s protocol?</em> How does it contribute to Spanner’s guarantee?
How should we design a system without such atomic clocks?</p>

<h2 id="spanner-in-a-nutshell">Spanner in a Nutshell</h2>

<p>Spanner is a geo-distributed database built by Google. 
Spanner has a data model that is stronger than key-value stores but weaker 
than fully relational databases.<br />
Spanner adopts a layered design, with concurrency control (2PL) on top of 
replication (Paxos). This design is easy to maintain, but it may 
cause extra RTTs. Spanner has three types of transactions, namely read-write (RW) transactions, 
consistent read-only 
transactions (RO), and stale snapshot transactions (the namings may be 
a little bit different from its original paper).</p>

<p>The key weapon of Spanner is its TrueTime API based on atomic clocks and GPS. 
The TrueTime API has a (at least practically) guaranteed offset among 
clocks. Compared to traditional non-synchronized clocks, a node 
in Spanner can predicate that a remote node’s clock has passed \(T\) 
without communication, which brings Spanner unique strength on efficiently 
ensuring consistency.</p>

<h2 id="spanners-consistencyisolation">Spanner’s Consistency/Isolation</h2>

<p>For read-write (RW) transactions, Spanner uses (strict) 2PL for concurrency control and 
uses leader-based Paxos for replication. A RW transaction is triggered by its client: the 
client first acquires all read locks, reads all values, and buffers all writes; 
then, a client acquires all write locks and commits via 2PC. This is a standard 2PL,
 and it actually 
already ensures Strict Serializability (even with replication, as all read/write requests
go through the leader) without TrueTime. A key invariant when assigning timestamp is 
that the timestamp order should be the same as the equivalent serial order of 2PL.</p>

<p>For read-only (RO) transactions, Spanner uses TrueTime to ensure their consistency. 
For consistency, there are two main requirements for a RO transaction \(R\) at timestamp \(ts\). 
First, Spanner needs to ensure that \(R\) sees <em>all</em> writes with timestamps smaller than
\(ts\). This completeness enures <em>atomicity</em> because updates from the same transaction share the 
same timestamp, so completeness already infers atomicity. 
The completeness also preserves <em>serializability</em>: RW transactions are serialized 
according to their timestamps, so completeness ensures that there is no gap in the 
equivalent serial schedule of RW transactions. Completeness together with 
the second requirement below also ensures the strictness of serializability.</p>

<p>Second, to ensure “strictness” in strict serializability, Spanner must 
ensure that a RO transaction’s timestamp is larger than all completed 
RW transactions’. This is where Spanner’s TrueTime comes to help. Since 
nodes’ clocks have a bounded offset, consider a RO transaction \(R\) starting at
\(t\). When \(R\) starts, any other node’s clock is at most \(t +\frac{1}{2} offset\). 
Therefore, assigning \(R\) with a timestamp larger than \(t +\frac{1}{2} offset\) is 
enough for consistency.</p>

<p>Without TrueTime, these two requirements become expensive to meet. For the first requirement, 
Two key aspects are (1) to ensure that nodes will not travel back in the history and assign 
transactions with past timestamps, and (2) to have a mechanism helping nodes to predicate 
that all on-the-flight transactions. Achieving these two aspects efficiently in a geo-distributed 
deployment is challenging. Ocean Vista <a class="citation" href="#oceanvista">(Fan &amp; Golab, 2019)</a> is an impressive work showing 
how these two aspects can be met with commodity hardware while still ensuring high performance. 
My previous work DAST <a class="citation" href="#chen2021achieving">(Chen et al., 2021)</a> also addresses these two aspects, but in a 
more specific near-client computing deployment scenarios: data is assigned home regions based on geo-locality, 
which brings DAST the potential for higher performance.</p>

<p>For the second requirement, without TrueTime, a system must keep track of the timestamp of finished 
transactions. This cannot be efficiently achieved in general cases for geo-distributed deployments, and 
normally a RO has to wait/communicate with delay in the order of global RTT time. 
This is actually in line with the SNOW <a class="citation" href="#snow">(Lu et al., 2016)</a> impossibility result, and explains why Google invest 
to build such a strong hardware to support RO transactions. 
There are two difficulties here. First, nodes’ clocks are not synchronized, so reading at a specific timestamp 
is bounded by the global straggler (who can assign relevant read-write transactions). DAST somehow 
sidesteps this difficulty because in DAST, for each key \(K\), only a restricted set of local nodes 
can assign timestamps to RW transactions accessing \(K\). Second, most systems do not explicitly record the time 
when each transaction <em>finishes</em>, so to ensure strict serializability, the system has to include a conservative 
superset of finished transactions (e.g., those who are assigned timestamps). This superset makes the RO 
must wait for un-finished transactions.</p>

<p>Overall, there seems to be two chances for improving RO transactions in Strictly serializable databases:
(1) strong data ownership based on locality (e.g,. SLOG <a class="citation" href="#oceanvista">(Fan &amp; Golab, 2019)</a>), 
and (2) leveraging strongly synchronized clocks (e.g., recent works on NSDI <a class="citation" href="#geng2018exploiting">(Geng et al., 2018; Najafi &amp; Wei, 2022)</a> )</p>

<h2 id="references">References:</h2>

<ol class="bibliography"><li><!-- _layouts/bib.html -->
      <div class="row">
        <!-- Entry bib key -->
        <div id="najafi2022graham" class="col-sm-12">
        
          <!-- Author -->
          <span class="author">Ali Najafi, &nbsp;and Michael Wei
          </span>.
          <!-- Title -->
          <span class="title">Graham: Synchronizing Clocks by Leveraging Local Clock Properties</span>.
          <!-- Journal/Book title and date -->
          <span class="periodical">
            <em>In 19th USENIX Symposium on Networked Systems Design and Implementation (NSDI 22)</em> 2022
          </span>
        
          <!-- Links/Buttons -->
          <div class="links">
          </div>

          
        </div>
      </div>
</li>
<li><!-- _layouts/bib.html -->
      <div class="row">
        <!-- Entry bib key -->
        <div id="chen2021achieving" class="col-sm-12">
        
          <!-- Author -->
          <span class="author">
                  <em>Xusheng Chen </em>,&nbsp;<a href="https://haozesong.github.io/">Haoze Song </a>,&nbsp;<a href="http://i.cs.hku.hk/~jyjiang/">Jianyu Jiang </a>,&nbsp;Chaoyi Ruan, &nbsp;<a href="http://staff.ustc.edu.cn/~chengli7/">Cheng Li </a>,&nbsp;Sen Wang, &nbsp;Gong Zhang, &nbsp;<a href="http://i.cs.hku.hk/~ckcheng">Reynold Cheng </a>,&nbsp;and <a href="http://i.cs.hku.hk/~heming/">Heming Cui </a>
                  
          </span>.
          <!-- Title -->
          <span class="title">Achieving low tail-latency and high scalability for serializable transactions in edge computing</span>.
          <!-- Journal/Book title and date -->
          <span class="periodical">
            <em>In Proceedings of the Sixteenth European Conference on Computer Systems</em> 2021
          </span>
        
          <!-- Links/Buttons -->
          <div class="links">
          </div>

          
        </div>
      </div>
</li>
<li><!-- _layouts/bib.html -->
      <div class="row">
        <!-- Entry bib key -->
        <div id="oceanvista" class="col-sm-12">
        
          <!-- Author -->
          <span class="author">Hua Fan, &nbsp;and Wojciech Golab
          </span>.
          <!-- Title -->
          <span class="title">Ocean vista: gossip-based visibility control for speedy geo-distributed transactions</span>.
          <!-- Journal/Book title and date -->
          <span class="periodical">
            <em>Proceedings of the VLDB Endowment</em> 2019
          </span>
        
          <!-- Links/Buttons -->
          <div class="links">
          </div>

          
        </div>
      </div>
</li>
<li><!-- _layouts/bib.html -->
      <div class="row">
        <!-- Entry bib key -->
        <div id="geng2018exploiting" class="col-sm-12">
        
          <!-- Author -->
          <span class="author">Yilong Geng, &nbsp;Shiyu Liu, &nbsp;Zi Yin, &nbsp;Ashish Naik, &nbsp;Balaji Prabhakar, &nbsp;Mendel Rosenblum, &nbsp;and Amin Vahdat
          </span>.
          <!-- Title -->
          <span class="title">Exploiting a natural network effect for scalable, fine-grained clock synchronization</span>.
          <!-- Journal/Book title and date -->
          <span class="periodical">
            <em>In 15th USENIX Symposium on Networked Systems Design and Implementation (NSDI 18)</em> 2018
          </span>
        
          <!-- Links/Buttons -->
          <div class="links">
          </div>

          
        </div>
      </div>
</li>
<li><!-- _layouts/bib.html -->
      <div class="row">
        <!-- Entry bib key -->
        <div id="snow" class="col-sm-12">
        
          <!-- Author -->
          <span class="author">Haonan Lu, &nbsp;Christopher Hodsdon, &nbsp;Khiem Ngo, &nbsp;Shuai Mu, &nbsp;and Wyatt Lloyd
          </span>.
          <!-- Title -->
          <span class="title">The SNOW Theorem and Latency-Optimal Read-Only Transactions</span>.
          <!-- Journal/Book title and date -->
          <span class="periodical">
            <em>In 12th USENIX Symposium on Operating Systems Design and Implementation (OSDI 16)</em> 2016
          </span>
        
          <!-- Links/Buttons -->
          <div class="links">
          </div>

          
        </div>
      </div>
</li>
<li><!-- _layouts/bib.html -->
      <div class="row">
        <!-- Entry bib key -->
        <div id="spanner" class="col-sm-12">
        
          <!-- Author -->
          <span class="author">James C Corbett, &nbsp;Jeffrey Dean, &nbsp;Michael Epstein, &nbsp;Andrew Fikes, &nbsp;Christopher Frost, &nbsp;Jeffrey John Furman, &nbsp;Sanjay Ghemawat, &nbsp;Andrey Gubarev, &nbsp;Christopher Heiser, &nbsp;Peter Hochschild, &nbsp;and  others
          </span>.
          <!-- Title -->
          <span class="title">Spanner: Google’s globally distributed database</span>.
          <!-- Journal/Book title and date -->
          <span class="periodical">
            <em>ACM Transactions on Computer Systems (TOCS)</em> 2013
          </span>
        
          <!-- Links/Buttons -->
          <div class="links">
          </div>

          
        </div>
      </div>
</li></ol>]]></content><author><name></name></author><category term="thoughts" /><category term="consistency" /><category term="distributed-database" /><summary type="html"><![CDATA[Spanner uses Atomic Clocks for read-only transactions.]]></summary></entry><entry><title type="html">2PL vs Strict Serializability</title><link href="https://michaelxschen.github.io/blog/2022/2pl/" rel="alternate" type="text/html" title="2PL vs Strict Serializability" /><published>2022-03-10T00:00:00+00:00</published><updated>2022-03-10T00:00:00+00:00</updated><id>https://michaelxschen.github.io/blog/2022/2pl</id><content type="html" xml:base="https://michaelxschen.github.io/blog/2022/2pl/"><![CDATA[<p>Once I thought 2PL ensures serializability while S2PL ensures strict 
serializability. However, I was wrong, as 2PL is already strong enough for 
strict serializability, with assumptions: clients do not abort transactions (which is hard),
or the system commit dependent transactions.</p>

<p>The definition of 2PL is simple and clear. A transaction in 2PL 
is not able to grab locks once it starts to release locks. 
Consequently, the transaction’s life time can be divide into 
an <em>expanding phase</em> where the transaction keeps grabbing new locks, 
and a <em>shrinking phase</em> where the transaction keeps releasing locks. 
Intuitively, between these two phases, there will be a period of 
time where the transaction is holding all its locks and conducting
its operations.</p>

<p>Let’s use \(H(T)\) to represent the time period 
of transaction $$T$ holding all its locks (we do not need to 
distinguish the start/end event of this period).</p>

<p>Consider two conflicting transactions \(T_1\) and \(T_2\). 2PL 
ensures that \(H(T_1)\) and \(H(T_2)\) has no overlap; because otherwise, 
during the overlapped time, \(T_1\) and \(T_2\) both hold the locks 
of their shared keys, breaking the semantic of locks.</p>

<p>Say \(H(T_1)\) is before \(H(T_2)\) in real time. Then, \(T_2\) 
must grab the locks of shared keys after \(T_1\) releasing 
them, i.e., \(T_2\) is serialized after \(T_1\),  denoted by \(T_1 &lt;_S T_2\). 
The direct proposition 
here is that 2PL ensures serializability: if there 
is a cycle in the dependency graph \(T_1 &lt;_S .... &lt;_S T_1\), 
it means that \(T_1\) grab locks after \(T_1\) release them, 
violating 2PL’s definition.</p>

<p>2PL also ensures strict serializability, which can be proved 
by contradiction. Suppose \(T_x\) finishes before \(T_y\) starts, 
but the serial order is \(T_y &lt;_S ....&lt;_S T_x\). This means 
\(T_x\) grabs some locks after \(T_y\) releasing them, contradicting 
with the assumption.</p>

<p>Therefore, 2PL is already enough for Strict Serializability.</p>

<p>TODO: S2PL</p>]]></content><author><name></name></author><category term="thoughts" /><category term="consistency" /><category term="distributed-database" /><summary type="html"><![CDATA[2PL ensures "strict" serializability, with assumptions]]></summary></entry><entry><title type="html">No-stale-reads vs real-time ordering</title><link href="https://michaelxschen.github.io/blog/2022/consistency/" rel="alternate" type="text/html" title="No-stale-reads vs real-time ordering" /><published>2022-03-01T00:00:00+00:00</published><updated>2022-03-01T00:00:00+00:00</updated><id>https://michaelxschen.github.io/blog/2022/consistency</id><content type="html" xml:base="https://michaelxschen.github.io/blog/2022/consistency/"><![CDATA[<p>TL;DR</p>

<p>For single key, no-stale-reads considers each read independently, 
while linearizability also restricts each read value w.r.t. other reads.
For multiple keys, things become a little bit complicated the overall theme is the same.</p>

<h2 id="background">Background</h2>

<p>When doing my projects, many times I got confused with the guarantee
of “the system provides no stale reads” (i.e., regularity) and “the system preserves
all real-time ordering requirements” (i.e.,  linearizability). I found two constructions to distinguish
them. The first construction (from 
<a class="citation" href="#nonstale:stack">(Overflow, n.d.)</a> is for single-key operations as shown below, where
<code class="language-plaintext highlighter-rouge">wwww</code> and <code class="language-plaintext highlighter-rouge">rrr</code> means the duration of one single write/read operation.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Key(x);  0                  1
P1:         wwwwwwwww(x=1)
P2:                rr(0)        
P3:         rr
</code></pre></div></div>
<p>In this construction,
P3’s read may return 0 or 1 if the system ensures “no stale reads”
because the read is concurrent to the write. However, P3’s read must return
0 as it precedes P2’s read in real-time: P3’s read must always be ordered before 
P2’s read in any history/schedule. Symmetrically, if P3’s read returns 
1, then P2’s read must not return 0.</p>

<p>The second construction is for transactional systems (the construction in my DAST paper <a class="citation" href="#chen2021achieving">(Chen et al., 2021)</a>).
Consider the following construction 
with two keys A and B. T2 and T3 only access one key each, while T1 is a distributed 
transaction accessing both keys. 
In this construction, we have $T2 -&gt; T3$ in real-time. However, the serializable order
(i.e., the equivalent serial schedule for serializability)
among these three transactions is $T3-&gt;T1-&gt;T2$, which breaks the real time-order. 
This construction does ensure no stale reads, but does not preserve all real-time 
ordering requirements.</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>A:   T1    T2
B:              T3    T1
</code></pre></div></div>

<p>Recently, I read the RSS paper <a class="citation" href="#helt2021regular">(Helt et al., 2021)</a>
, which helps to shed light on this problem. 
RSS ensures all reads see finished writes (i.e., no stale reads) and preserves 
the real-time ordering from write operations/transactions to other operations. 
RSS is proved to be <em>invariant-equivalent</em> to linearizability.
To understand the idea of invariant-equivalence, we need to first distinguish the
definitions of <em>invariants</em> and <em>anomalies</em>. Usually, invariants are defined 
from system/service’s pov, while anomalies are defined from the external view. 
For instance, a system/service cannot track whether two processes/clients 
contacts externally (e.g., Alice calls Bob after its operation finishes). Therefore, 
we usually refer to strict serializability and linearizability as <em>external consistency</em>:
the system/service is consistent even if one views the external world altogether where
processes/clients can communicate with no delay.</p>

<p>RSS paper writes, “like 
all prior <em>regular</em> models, (RSS ensures that) reads must return a value at least 
as recent as the most recently complete conflicting writes”. 
This sentence motivates me to dig deeper into the classical papers about
consistency levels.</p>

<h2 id="shared-registers">Shared Registers</h2>

<p>The basic single-write multiple-writer shared register model was first proposed by 
Lamport in 1986 <a class="citation" href="#lamport1986interprocess">(Lamport, 1986)</a>, together with the <em>atomic, regular, and safe</em> consistency models. 
This model only has one writer and one key, which serve as the base for all 
subsequent consistency models.</p>

<ul>
  <li>
    <p>A safe register ensures that a read not overlapping with writes returns the latest 
writes; otherwise, the reads can return any value (even a corrupted one). 
Note that in the basic model, 
there is only one writer, so no concurrent writes. Such registers may show in shared 
registers on chips <a class="citation" href="#lamport1986interprocess">(Lamport, 1986)</a>.</p>
  </li>
  <li>
    <p>A regular register is a little stronger. It also requires that reads must return the 
value that is at least as recent as latest finished writes, while it can freely 
choose whether to return the values of concurrent writes.</p>
  </li>
  <li>
    <p>An atomic register provides the strongest guarantee. In addition to previous requirements, 
it also requires that a subsequent read cannot returns a earlier value than a read 
finished before it (i.e., linearizability).</p>
  </li>
</ul>

<h2 id="back-to-the-motivation-cases">Back to the motivation cases.</h2>

<p>It is obvious that in the first construction, a consistency model ensuring this can be called as 
<em>regular</em>, like in RSS. Note that this is not Monotonic Read guarantee, as MR guarantee is defined
only within session. It is also <em>sequential</em>, but not linearizability.</p>

<p>In the second construction, however, things are a little complicated as the original model 
only involves one register. 
In essence, the difference between the two constructions is that P3’s read is read-only, while T2 is not.</p>

<p>The key ambiguity sources from the fact that Lamport’s original paper only defines 
regularity for single register: read must see a version at least as recent as 
the latest finished writes. However, this construction has two registers, but the definition 
does not discuss the relation of two (unrelated) writes on two different registers. 
As far as I am concerned, there 
is only one work <a class="citation" href="#viotti2016consistency">(Viotti &amp; Vukolić, 2018)</a> that
defines regularity for multiple keys with the following three requirements:</p>

<ul>
  <li>There is an equivalent total order (a.k.a., the arbitration order) of all requests.</li>
  <li>This order respects the real-time order (a.k.a., the “return before” relation) from writes to any operations.</li>
  <li>The system is return value consistent, i.e., the return value is as expected. This is 
    a very weak guarantee, but the atomic register model does not ensure this.</li>
</ul>

<p>This definition also requires the real-time ordering from a write to an un-related 
operation must also be preserved. The RSS paper follows this definition. If we adopt
this definition, the second construction is <em>not regular</em>, as it does not 
the real-time ordering between T2 and T3 if T2 contains write operations.</p>

<p>However, this general definition has not reached an agreement in academia/industry,
as the intuition behind Lamport’s definition of “regularity” is that the register 
has no stale reads: all finished writes must be visible to subsequent reads
until it is overwritten.</p>

<p>I will discuss more regular consistency models defined in <a class="citation" href="#shao2011multiwriter">(Shao et al., 2011)</a>
on multi-writer regularity
in subsequent posts.</p>

<h2 id="references">References:</h2>

<ol class="bibliography"><li><!-- _layouts/bib.html -->
      <div class="row">
        <!-- Entry bib key -->
        <div id="helt2021regular" class="col-sm-12">
        
          <!-- Author -->
          <span class="author">Jeffrey Helt, &nbsp;Matthew Burke, &nbsp;Amit Levy, &nbsp;and Wyatt Lloyd
          </span>.
          <!-- Title -->
          <span class="title">Regular Sequential Serializability and Regular Sequential Consistency</span>.
          <!-- Journal/Book title and date -->
          <span class="periodical">
            <em>In Proceedings of the ACM SIGOPS 28th Symposium on Operating Systems Principles</em> 2021
          </span>
        
          <!-- Links/Buttons -->
          <div class="links">
          </div>

          
        </div>
      </div>
</li>
<li><!-- _layouts/bib.html -->
      <div class="row">
        <!-- Entry bib key -->
        <div id="chen2021achieving" class="col-sm-12">
        
          <!-- Author -->
          <span class="author">
                  <em>Xusheng Chen </em>,&nbsp;<a href="https://haozesong.github.io/">Haoze Song </a>,&nbsp;<a href="http://i.cs.hku.hk/~jyjiang/">Jianyu Jiang </a>,&nbsp;Chaoyi Ruan, &nbsp;<a href="http://staff.ustc.edu.cn/~chengli7/">Cheng Li </a>,&nbsp;Sen Wang, &nbsp;Gong Zhang, &nbsp;<a href="http://i.cs.hku.hk/~ckcheng">Reynold Cheng </a>,&nbsp;and <a href="http://i.cs.hku.hk/~heming/">Heming Cui </a>
                  
          </span>.
          <!-- Title -->
          <span class="title">Achieving low tail-latency and high scalability for serializable transactions in edge computing</span>.
          <!-- Journal/Book title and date -->
          <span class="periodical">
            <em>In Proceedings of the Sixteenth European Conference on Computer Systems</em> 2021
          </span>
        
          <!-- Links/Buttons -->
          <div class="links">
          </div>

          
        </div>
      </div>
</li>
<li><!-- _layouts/bib.html -->
      <div class="row">
        <!-- Entry bib key -->
        <div id="viotti2016consistency" class="col-sm-12">
        
          <!-- Author -->
          <span class="author">Paolo Viotti, &nbsp;and Marko Vukolić
          </span>.
          <!-- Title -->
          <span class="title">Consistency in non-transactional distributed storage systems</span>.
          <!-- Journal/Book title and date -->
          <span class="periodical">
            <em>ACM Computing Surveys (CSUR)</em> 2018
          </span>
        
          <!-- Links/Buttons -->
          <div class="links">
          </div>

          
        </div>
      </div>
</li>
<li><!-- _layouts/bib.html -->
      <div class="row">
        <!-- Entry bib key -->
        <div id="shao2011multiwriter" class="col-sm-12">
        
          <!-- Author -->
          <span class="author">Cheng Shao, &nbsp;Jennifer L Welch, &nbsp;Evelyn Pierce, &nbsp;and Hyunyoung Lee
          </span>.
          <!-- Title -->
          <span class="title">Multiwriter consistency conditions for shared memory registers</span>.
          <!-- Journal/Book title and date -->
          <span class="periodical">
            <em>SIAM Journal on Computing</em> 2011
          </span>
        
          <!-- Links/Buttons -->
          <div class="links">
          </div>

          
        </div>
      </div>
</li>
<li><!-- _layouts/bib.html -->
      <div class="row">
        <!-- Entry bib key -->
        <div id="lamport1986interprocess" class="col-sm-12">
        
          <!-- Author -->
          <span class="author">Leslie Lamport
          </span>.
          <!-- Title -->
          <span class="title">On interprocess communication</span>.
          <!-- Journal/Book title and date -->
          <span class="periodical">
            <em>Distributed computing</em> 1986
          </span>
        
          <!-- Links/Buttons -->
          <div class="links">
          </div>

          
        </div>
      </div>
</li>
<li><!-- _layouts/bib.html -->
      <div class="row">
        <!-- Entry bib key -->
        <div id="nonstale:stack" class="col-sm-12">
        
          <!-- Author -->
          <span class="author">Stack Overflow
          </span>.
          <!-- Title -->
          <span class="title">https://stackoverflow.com/questions/8871633/whats-the-difference-between-safe-regular-and-atomic-registers</span>.
          <!-- Journal/Book title and date -->
          <span class="periodical">
            <em></em> 1986
          </span>
        
          <!-- Links/Buttons -->
          <div class="links">
          </div>

          
        </div>
      </div>
</li></ol>]]></content><author><name></name></author><category term="thoughts" /><category term="consistency" /><category term="distributed-database" /><summary type="html"><![CDATA[Some discussions on consistency models.]]></summary></entry></feed>